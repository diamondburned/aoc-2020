package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"strconv"
	"strings"
)

// This code to remain largely unaltered from the state it was used to solve,
// mostly for historical purposes.

var (
	acc = "acc"
	jmp = "jmp"
	nop = "nop"
)

func main() {
	f, err := ioutil.ReadFile("input")
	if err != nil {
		log.Panicln(err)
	}

	type ins struct {
		op string
		v  int
	}

	var lines = strings.Split(string(f), "\n")
	var instructions = make([]ins, 0, len(lines))

	for _, line := range lines {
		parts := strings.Fields(line)
		if len(parts) == 0 {
			continue
		}

		op, v := parts[0], parts[1]

		n, err := strconv.Atoi(v)
		if err != nil {
			log.Panicln(err)
		}

		instructions = append(instructions, ins{op, n})
	}

	var accumulator = 0
	var executed = map[int]int{}

	var lastJmp int
	var tried = map[int]struct{}{}

Main:
	for {
		instructions := append([]ins(nil), instructions...)
		detected := false

		log.Println("Attempting...")

	Sub:
		for try := 0; try < 2; try++ {
			accumulator = 0
			lastJmp = -1
			executed = map[int]int{}

			for i := 0; i < len(instructions); {
				if time := executed[i]; time > 10 && lastJmp >= 0 {
					if _, haveTried := tried[lastJmp]; !haveTried {
						log.Println("Have not tried", lastJmp)

						if detected {
							tried[lastJmp] = struct{}{}
							break Sub
						}

						log.Println("lastJmp loop detected at", lastJmp)
						instructions[lastJmp] = ins{nop, 0}
						detected = true
					}

					break
				}

				executed[i]++

				switch ins := instructions[i]; ins.op {
				case acc:
					accumulator += ins.v
				case jmp:
					lastJmp = i
					i += ins.v
					continue
				case nop:
				}

				i++
			}
		}

		if !detected {
			break Main
		}
	}

	fmt.Println(accumulator)

	// var total int

	// for _, group := range groups {
	// 	var answer = map[rune]struct{}{}

	// 	for _, char := range group {
	// 		if char == '\n' {
	// 			continue
	// 		}

	// 		answer[char] = struct{}{}
	// 	}

	// 	total += len(answer)
	// }

	// fmt.Println(total)
}
